// TODO    Virtual dom
// Что за виртуал дом? и как он работает
//

// Расскажи про реакт файбер

// TODO   PureComponent , альтернатива Pure  в классовой компоненте




// TODO    для чего нужен key



// TODO  Что такое HOC и зачем они нужны, пример


// TODO   Рефы

// TODO жизненный цикл

// ДО РЕНДЕРИНГА
// constructor(props): конструктор, в котором происходит начальная инициализация компонента
//
// static getDerivedStateFromProps(props, state): вызывается непосредственно перед рендерингом компонента.
//
// render(): рендеринг компонента
//
// componentDidMount(): вызывается после рендеринга компонента. Здесь можно выполнять запросы к удаленным ресурсам
//
// componentWillUnmount(): вызывается перед удалением компонента из DOM
// ПОСЛЕ РЕНДЕРИНГА
// static getDerivedStateFromProps(props, state)
//
// shouldComponentUpdate(nextProps, nextState): вызывается каждый раз при обновлении объекта props или state. В качестве параметра передаются новый объект props и state. Эта функция должна возвращать true (надо делать обновление) или false (игнорировать обновление). По умолчанию возвращается true. Но если функция будет возвращать false, то тем самым мы отключим обновление компонента, а последующие функции не будут срабатывать.
//
// render(): рендеринг компонента (если shouldComponentUpdate возвращает true)
//
// componentDidUpdate(prevProps, prevState): вызывается сразу после обновления компонента (если shouldComponentUpdate возвращает true)

// TODO хуки , стандартные, кастомные

// useState
// useEffect
// useContext
// useReducer => к этому хуку мы ещё вернёмся
// useCallback
// useMemo
// useRef

// TODO правила использования хуков
// хуки нельзя вызывать в условиях и циклах. Использовать только в компонентах или кастомных хуках
// для каждого компонента реакт использует обычный массив для сохранения значений,которые нужны для работы хуков. Как только нарушается последовательность, посредставам условий - хуки перестают нормально работать

// TODO Error boundary , отловка ошибок в компонентах , и возмоожно ли это сделать в функциональных
// это своего рода HOC . нужно создать классоый компонент , определить метод getDerivedStateFromerror , componentDidCatch . И если в компоненте есть ошибка,то можно отрисовать запасной UI
// Работают как js блоки catch

// TODO  React context


// TODO Неуправляемые компоненты


